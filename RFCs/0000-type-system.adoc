= PartiQL Type System
John E. Quinn <johnedquinn@gmail.com>
:description: Defining PartiQL's Types
:url-repo: https://github.com/johnedquinn/partiql-lang
:revdate: 2024-05-01
:revnumber: 1
:revremark: Defining PartiQL's Types
:sectlinks:
:sectanchors:
:sectnums:
:sectnumlevels: 4
:toc: left
:toclevels: 4
:toc-title: Contents

[preface]
== Preface

=== Overview

This document aims to formalize the types that make up PartiQL's type system, the built-in functions that PartiQL implementations must implement, the relationships between types, and function resolution.

To see the original RFC, please see link:https://github.com/partiql-lang/TODO[here].

=== Motivation

The PartiQL Team is currently working towards a long-term support (LTS) version (1.0) of PartiQL for the JVM implementation. As the type system defines the very foundation upon how functions, operators, and values operate, this document aims to formalize our type semantics before releasing version 1.0.

=== Document Format

The remainder of this document aims to write itself in a way that will enable the PartiQL Maintainers to copy and paste its contents directly into the PartiQL Specification. That being said, this document has intentionally chosen to deviate from PartiQL's RFC template.

== Data Types

PartiQL inherits the following categories of pre-defined types from SQL:1999:
[quote, SQL:1999]
____
— The data types CHARACTER, CHARACTER VARYING, and CHARACTER LARGE OBJECT are collectively referred to as character string types. +
— The data types BIT and BIT VARYING are collectively referred to as bit string types. +
— The data type BINARY LARGE OBJECT is referred to as the binary string type and the values of binary string types are referred to as binary strings. +
— The data types CHARACTER LARGE OBJECT and BINARY LARGE OBJECT are collectively referred to as large object string types and the values of large object string types are referred to as large object strings. +
— Character string types, bit string types, and binary string types are collectively referred to as string types and values of string types are referred to as strings. +
— The data types NUMERIC, DECIMAL, INTEGER and SMALLINT are collectively referred to as exact numeric types. +
— The data types FLOAT, REAL, and DOUBLE PRECISION are collectively referred to as approximate numeric types. +
— Exact numeric types and approximate numeric types are collectively referred to as numeric types. Values of numeric types are referred to as numbers. +
— The data types TIME WITHOUT TIME ZONE and TIME WITH TIME ZONE are collectively referred to as time types (or, for emphasis, as time with or without time zone). +
— The data types TIMESTAMP WITHOUT TIME ZONE and TIMESTAMP WITH TIME ZONE are collectively referred to as timestamp types (or, for emphasis, as timestamp with or without time zone). +
— The data types DATE, time, and timestamp are collectively referred to as datetime types. +
— Values of datetime types are referred to as datetimes. +
— The data type INTERVAL is referred to as an interval type. Values of interval types are called intervals.
____

Beyond these pre-defined types established by SQL:1999, PartiQL proposes additional types categorized as follows:

- The data types ARRAY, BAG, and TUPLE are collectively referred to as complex types.
- The data types ARRAY and BAG are collectively referred to as collection types.
- The data type TUPLE is referred to as a tuple type.
- The data types NULL and MISSING are collectively referred to as absent types.
- The data type DYNAMIC is referred to as a dynamic type. There are no values that may be of the dynamic type.
- The data types TINYINT, BIGINT, and UNBOUNDED INT are added to the definition of exact numeric types.
- The data type SYMBOL is added to the definition of character string types.
- And, since SQL:1999 did not categorize boolean types: The data type BOOLEAN is referred to as a boolean type.

Subsequent sections in this RFC elaborate on the semantics of the above mentioned types.

Below are the enumerated pre-defined PartiQL predefined data types:

[#data-types-table]
.PartiQL Data Types
[cols="3,3,1"]
|===
|PartiQL Data Type |Aliases |In SQL:1999

|DYNAMIC
|
|N

|NULL
|
|N

|MISSING
|
|N

|TUPLE
|STRUCT
|N

|ARRAY
|LIST
|M

|BAG
|
|N

|CHARACTER
|CHAR
|Y

|CHARACTER VARYING
|VARCHAR, STRING
|M

|CHARACTER LARGE OBJECT
|CLOB
|M

|BINARY LARGE OBJECT
|BLOB
|M

|BIT
|
|Y

|BIT VARYING
|
|Y

|TINYINT
|INT8, INTEGER8
|N

|SMALLINT
|INT16, INTEGER16
|M

|INTEGER
|INT, INTEGER32, INT32
|M

|BIGINT
|INT64, INTEGER64
|N

|UNBOUNDED INT
|
|N

|NUMERIC
|DECIMAL, DEC
|Y

// TODO: Add annotation to talk about why this exists
|UNBOUNDED NUMERIC
|UNBOUNDED DECIMAL, UNBOUNDED DEC
|N

|REAL
|
|Y

|DOUBLE PRECISION
|
|Y

|FLOAT
|
|Y

|TIME WITH TIME ZONE
|
|M

|TIME WITHOUT TIME ZONE
|
|M

|TIMESTAMP WITH TIME ZONE
|
|M

|TIMESTAMP WITHOUT TIME ZONE
|
|M

|DATE
|
|Y

|INTERVAL
|
|Y
|===

Above, in <<data-types-table>>, the options Y, M, and N correpond to the words YES, MODIFIED, and NO, respectively. If the entry contains MODIFIED, further sections shall establish how the corresponding type differs from that of SQL:1999. Similarly, if the entry contains NO, further sections shall introduce the data type. If the entry contains YES, this document shall not elaborate on the corresponding type, and readers shall refer to SQL:1999 for information regarding its syntax and semantics.

== Dynamic Type

==========
*Name*: DYNAMIC +
*Aliases*: <None> +
*In SQL:1999*: NO
==========

When the PartiQL compiler does not have enough information to infer a value's type, it uses the dynamic type.

[quote, Dart Programming Language]
____
Dynamic ... indicates that you want to disable static checking.
____

Note that the dynamic type is not a runtime type. It is solely used during compilation to defer type-checking until the runtime. That being said, the dynamic type plays a unique role in function resolution. The consequence of using the dynamic type in operations and functions is described in more detail in link:https://github.com/partiql-lang/TODO[RFC-TODO].

During PartiQL's static type analysis, interactions with the dynamic type _almost_ always lead to propagation of the dynamic type. For example, consider the following operation:

[source, partiql]
----
-- Assume a is DYNAMIC, b is INT
a + b -- The resulting compile-time type would be DYNAMIC
----

.EBNF
[source,ebnf]
----
(* Type *)
<dynamic type> ::=
    DYNAMIC
----

.Example Usage
[source,partiql]
----
-- Below, a person might have expressed their address as just a zip-code (string), ...
-- ... or a struct containing fields such as "city", "street", etc.
CREATE TABLE Person (
    ssn STRING NOT NULL,
    age INT,
    name STRING,
    address DYNAMIC
);
----

== Character Strings

=== Character Varying Type

==========
*Name*: CHARACTER VARYING +
*Aliases*: VARCHAR, STRING +
*In SQL:1999*: MODIFIED
==========

XX

=== Symbol Type

==========
*Name*: SYMBOL +
*Aliases*: <None> +
*In SQL:1999*: NO
==========

PartiQL supports the SYMBOL type, which has the same semantics as CHARACTER VARYING.

.EBNF
[source,ebnf]
----
(* Type *)
<symbol type> ::=
    SYMBOL

(* Literals *)
<symbol literal> ::=
    SYMBOL <string literal>
----

TIP: As a historical aside, the symbol type exists primarily for compatibility with Ion, which has the symbol type. By allowing for the SYMBOL type, PartiQL users have the ability to manipulate symbols using common operations such as concatenation and substring. For more information, see link:https://github.com/partiql-lang/TODO[RFC-TODO].

== Large Object Strings

The Large Object String types of CHARACTER LARGE OBJECT and BINARY LARGE OBJECT remain largely the same as in SQL:1999, however, their size limitations are removed in PartiQL.

.EBNF
[source,ebnf]
----
(* Literals *)
<character large object type> ::=
    CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
    | CHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
    | CLOB [ <left paren> <large object length> <right paren> ]

<binary large object type> ::=
    BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ]
    | BLOB [ <left paren> <large object length> <right paren> ]
----

If <large object length> is not specified, then UNCONSTRAINED is assumed. With this in place, PartiQL shall allow for variable unlimited length large object strings (up to implementation limits).

TIP: As a historical aside, the unconstrained aspect of large object strings exists primarily for compatibility with Ion.

== Numbers

=== Exact Numeric Types

.EBNF
[source,ebnf]
----
(* Literals *)
<exact numeric literal> ::=
    <unsigned integer> [ <period> [ <unsigned integer> ] ]
    | <period> <unsigned integer>
----

From SQL:
[quote, SQL:1999]
____
The declared type of an <exact numeric literal> is exact numeric. The precision of an <exact
numeric literal> is the number of <digit>s that it contains. The scale of an <exact numeric
literal> is the number of <digit>s to the right of the <period>.
____

==== Tiny Integer Type

==========
*Name*: TINYINT +
*Aliases*: INT8 +
*In SQL:1999*: NO
*Binary Precision*: 8
==========

The TINYINT type is a signed integer represented in 8 bits (1 byte).

==== Small Integer Type

==========
*Name*: SMALLINT +
*Aliases*: INT16 +
*In SQL:1999*: MODIFIED
*Binary Precision*: 16
==========

In contrast to SQL:1999, PartiQL prescribes a specific binary precision to an SMALLINT. It is a signed integer represented in 16 bits (2 bytes).

==== Integer Type

==========
*Name*: INTEGER +
*Aliases*: INT, INT32 +
*In SQL:1999*: MODIFIED
*Binary Precision*: 32
==========

In contrast to SQL:1999, PartiQL prescribes a specific binary precision to an INTEGER. It is a signed integer represented in 32 bits (4 bytes).

==== Big Integer Type

==========
*Name*: BIGINT +
*Aliases*: LONG, INT64 +
*In SQL:1999*: NO
*Binary Precision*: 64
==========

The BIGINT type is a signed integer represented in 64 bits (8 bytes).

==== Numeric Type

==========
*Name*: NUMERIC +
*Aliases*: DECIMAL, DEC +
*In SQL:1999*: MODIFIED
==========

The NUMERIC data type is largely the same as in SQL:1999, however, its allowable bounds for decimal precision and scale have been modified.

.Numeric Parameters
[cols="1,1,3"]
|===
|Parameter |Type |Range

|precision
|int
|- (1, MFP], where MFP is the implementation-defined maximum finite decimal precision for the NUMERIC type. +
- UNBOUNDED, otherwise known as MP, the maximum precision for the NUMERIC type.

|scale
|int
|- [0, precision], when precision in (1, MFP]. +
- 0 OR UNBOUNDED, when precision is UNBOUNDED.
|===

.EBNF
[source,ebnf]
----
(* Type *)
<numeric type> ::= (* In SQL:1999, this would be <exact numeric type> *)
    NUMERIC [ <left paren> <numeric precision> [ <comma> <numeric scale> ] <right paren> ]
    | DECIMAL [ <left paren> <numeric precision> [ <comma> <numeric scale> ] <right paren> ]
    | DEC [ <left paren> <numeric precision> [ <comma> <numeric scale> ] <right paren> ]

<numeric precision> ::=
    <precision> (* Derived from SQL:1999 *)
    | UNCONSTRAINED

<numeric scale> ::=
    <scale> (* Derived from SQL:1999 *)
    | UNCONSTRAINED
----

The current recommendation is for users to specify both <numeric precision> and <numeric scale>.

When <numeric precision> and <numeric scale> are not specified, this creates an "unconstrained" numeric in which numeric values of any length can be stored, up to the implementation limits. A column of this kind will not coerce input values to any particular scale, whereas numeric columns with a declared scale will coerce input values to that scale.

[source, partiql]
----
NUMERIC(5, 2) -- Specifies a numeric of precision 5 and scale 2

NUMERIC(10, UNCONSTRAINED) -- Specifies a numeric of precision 5 and unconstrained scale

NUMERIC(UNCONSTRAINED, 0) -- Specifies a numeric of unconstrained precision and scale 0
----

If <numeric precision> is specified but <numeric scale> is absent, then <numeric scale> is assumed to be 0:

[source, partiql]
----
-- The two below are equivalent
NUMERIC(UNCONSTRAINED, 0)
NUMERIC(UNCONSTRAINED)

-- The two below are equivalent
NUMERIC(5, 0)
NUMERIC(5)
----

If both <numeric precision> and <numeric scale> are absent, a precision of UNCONSTRAINED and a scale of UNCONSTRAINED are assumed:

[source, partiql]
----
-- The two below are equivalent
NUMERIC
NUMERIC(UNCONSTRAINED, UNCONSTRAINED)
----

.Example Usage
[source,partiql]
----
-- Example for using an unbounded "integer" (synonymous with Ion's integer)
CREATE TABLE orders (
    order_id NUMERIC(UNCONSTRAINED, 0),
    item_id NUMERIC(UNCONSTRAINED), -- Equivalent to the above line
    quantity SMALLINT,
    orderee_id NUMERIC(15, 0)
);

-- Example for using an unbounded decimal (synonymous with Ion's decimal)
CREATE TABLE planetary_coordinates (
    x NUMERIC(UNCONSTRAINED, UNCONSTRAINED),
    y NUMERIC(UNCONSTRAINED, UNCONSTRAINED),
    z NUMERIC -- this column has the same type as the above two lines
);
----

TIP: As a historical aside, the unconstrained numeric types exist primarily for compatibility with Ion, which has support for arbitrary precision decimals and integers.

== Datetime Types

The datetime types of TIME WITH TIME ZONE, TIME WITHOUT TIME ZONE, TIMESTAMP WITH TIME ZONE, and TIMESTAMP WITHOUT TIME ZONE data types are largely the same as in SQL:1999, however, their allowable bounds for precision have been modified.

.EBNF
[source,ebnf]
----
<datetime type> ::=
    DATE
    | TIME [ <left paren> <partiql time precision> <right paren> ]
        [ <with or without time zone> ]
    | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
        [ <with or without time zone> ]

<with or without time zone> ::=
    WITH TIME ZONE
    | WITHOUT TIME ZONE

<partiql time precision> ::=
    <time precision> (* from SQL:1999 *)
    | UNCONSTRAINED

<partiql timestamp precision> ::=
    <timestamp precision> (* from SQL:1999 *)
    | UNCONSTRAINED

<time precision> ::= <time fractional seconds precision>

<timestamp precision> ::= <time fractional seconds precision>

<time fractional seconds precision> ::= <unsigned integer>
----

Dissimilar to SQL:1999, TIME and TIMESTAMP types are able to specify an unconstrained precision to allow for Ion timestamps. When <partiql time precision> is not specified, this creates an "unconstrained" time or timestamp in which fractional seconds of any length can be stored, up to the implementation limits.

If <partiql time precision> is absent, a precision of UNCONSTRAINED is assumed. If <partiql timestamp precision> is absent, a precision of UNCONSTRAINED is assumed. For example:

[source, partiql]
----
-- The two below are equivalent
TIME WITH TIME ZONE
TIME(UNCONSTRAINED) WITH TIME ZONE

-- The two below are equivalent
TIMESTAMP WITH TIME ZONE
TIMESTAMP(UNCONSTRAINED) WITH TIME ZONE
----

.Example Datetime Usage
[source,partiql]
----
-- Example for using a standard time and timestamp
CREATE TABLE daily_events (
    event_id BIGINT,
    event_time TIME(5) WITH TIME ZONE,
    created_timestamp TIMESTAMP(5) WITH TIME ZONE
);

-- Example for using an unconstrained time/timestamp
CREATE TABLE solar_eclipses (
    event_id BIGINT,
    event_timestamp TIMESTAMP(UNCONSTRAINED) WITH TIME ZONE,
    event_timestamp_simple TIMESTAMP WITH TIME ZONE, -- equivalent with line above
    daily_sync_time TIME WITH TIME ZONE -- unconstrained time
);
----

== Interval Type

==========
*Name*: INTERVAL +
*Aliases*: <None> +
*In SQL:1999*: MODIFIED
==========

The INTERVAL data type is largely the same as in SQL:1999, however, its allowable bounds for fractional seconds precision (decimal) has been modified.

.EBNF
[%nowrap]
[source,ebnf]
----
<interval qualifier> ::=
    <start field> TO <end field>
    | <single datetime field>

<start field> ::=
    <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]

<end field> ::=
    <non-second primary datetime field>
    | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]

<single datetime field> ::=
    <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
    | SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]

<primary datetime field> ::=
    <non-second primary datetime field>
    | SECOND

<non-second primary datetime field> ::= YEAR | MONTH | DAY | HOUR | MINUTE

<interval fractional seconds precision> ::=
    <interval fractional seconds precision constrained>
    | UNCONSTRAINED

<interval fractional seconds precision constrained> ::= <unsigned integer>

<interval leading field precision> ::= <unsigned integer>
----

In the case where <interval fractional seconds precision> is defined and is not UNCONSTRAINED, it shall be greater than or equal to 0 (zero) and shall not be greater than the implementation-defined maximum. The maximum value of <interval fractional seconds precision constrained> is implementation-defined, but shall not be less than 6.

In the case where either i) <interval fractional seconds precision> is absent and SECOND is specified, or ii) <interval fractional seconds precision> is specified to be UNCONSTRAINED, then there shall be no explicit bound on fractional seconds precision.

NOTE: This is in contrast to SQL:1999 which states: "If SECOND is specified and <interval fractional seconds precision> is not specified, then an <interval fractional seconds precision> of 6 is implicit."

== Collection Types

A collection is a composite value comprising zero or more elements each a value of some data type, DT. For all collection types, DT may be the DYNAMIC type -- allowing for collections of heterogeneous types.

=== Bag Type

==========
*Name*: BAG +
*Aliases*: <None> +
*In SQL:1999*: NO
==========

A BAG is an unordered collection of values able to contain duplicates. As such, operations such as indexing shall not be allowed. More information on the usage and semantics of bags is described in detail in the link:https://github.com/partiql-lang/TODO[PartiQL Specification] as well as link:https://github.com/partiql-lang/TODO[RFC-TODO].

.EBNF
[%nowrap]
[source,ebnf]
----
(* Type *)
<bag type> ::=
    [ <data type> ] BAG

(* Literal *)
<bag value> ::=
    <bag value prefix> [ <bag element> [ { <comma> <bag element> }... ] ] <bag value postfix>

<bag value prefix> ::= <<

<bag value postfix> ::= >>
----

If <data type> is unspecified, DYNAMIC is assumed to be the DT of the bag.

NOTE: SQL:1999 has allowed for the specification of an ARRAY's size via styntax such as: `INT ARRAY[10]`. This RFC has not found a need to specify a constraint such as length. Therefore, one can assume that the length is unconstrained.

.Example Usage
[%nowrap]
[source,partiql]
----
-- Creating a table of users
CREATE TABLE users (
    user_id BIGINT,
    user_name STRING(30),
    favorite_foods VARCHAR(30) BAG,
    recent_purchases DYNAMIC BAG,
    recent_purchases_simple BAG -- equivalent to the above line
);

-- Creating a literal bag where DT is DYNAMIC
<<
    'this is the 0th element',
    1,
    'this is the 2nd element'
>>;

-- Querying against a literal bag where DT is TUPLE
SELECT VALUE t.a
FROM <<
    { 'a': 1 },
    { 'a': 2 }
>> AS t;
----

=== Array Type

==========
*Name*: ARRAY +
*Aliases*: LIST +
*In SQL:1999*: MODIFIED
==========

The ARRAY data type is largely the same as in SQL:1999, however, its allowable types now include all types discussed in this RFC (including the DYNAMIC type).

.EBNF
[%nowrap]
[source,ebnf]
----
(* Type *)
<array type> ::=
    [ <data type> ] ARRAY

(* Literal *)
<array literal> ::=
    <array literal prefix> [ <array element> [ { <comma> <array element> }... ] ] <array literal postfix>

<array literal prefix> ::= [

<array literal postfix> ::= ]
----

If <data type> is unspecified, DYNAMIC is assumed to be the DT of the array.

NOTE: SQL:1999 has allowed for the specification of an ARRAY's size via styntax such as: `INT ARRAY[10]`. This RFC has not found a need to specify a constraint such as length. Therefore, one can assume that the length is unconstrained.

.Example Usage
[%nowrap]
[source,partiql]
----
-- Creating a table of users
CREATE TABLE users (
    user_id BIGINT,
    user_name STRING(30),
    favorite_foods_in_order_of_favoritism VARCHAR(30) ARRAY,
    recent_purchases_in_order DYNAMIC ARRAY,
    recent_purchases_in_order_simple ARRAY -- equivalent to the above line
);

-- Creating a literal array where DT is DYNAMIC
[
    'this is the 0th element',
    1,
    'this is the 2nd element'
];

-- Querying against a literal array where DT is TUPLE
SELECT VALUE t.a
FROM [
    { 'a': 1 },
    { 'a': 2 }
 ] AS t;
----

== Tuple Type

==========
*Name*: TUPLE +
*Aliases*: STRUCT +
*In SQL:1999*: NO
==========

== Absent Types

=== Null Type

==========
*Name*: NULL +
*Aliases*: <None> +
*In SQL:1999*: NO
==========

PartiQL supports distinct null values for every core type, as well as a separate null type that is distinct from all other types. The singular value that it may represent is the NULL value.

An important aspect of the NULL type (and NULL value) is that it may be implicitly coerced into any other type.

=== Missing Type

==========
*Name*: MISSING +
*Aliases*: <None> +
*In SQL:1999*: NO
==========

As elaborated by the pre-existing PartiQL Specification, the MISSING type is a mechanism by which PartiQL queries may handle typing errors during the runtime (if permitted by the typing mode). To elaborate, typing errors that would normally result in a halt of execution shall be coerced to the MISSING value when in permissive mode.

The singular value that it may represent is the MISSING value. Note that, by default, all MISSING values are described as NOT NULL.

In both typing modes (strict and permissive), it is possible to create a MISSING literal.

.EBNF
[%nowrap]
[source,ebnf]
----
(* Type *)
<missing type> ::=
    MISSING

(* Literal *)
<missing literal> ::=
    MISSING
----

.Example Usage
[%nowrap]
[source,partiql]
----
SELECT VALUE t
FROM <<
    1,
    MISSING,
    3
>> AS t
----

For information about MISSING and its semantics, see link:https://github.com/partiql-lang/TODO[RFC-TODO].

== Other Types

PartiQL supports all other pre-defined types specified in SQL:1999, including:
- BOOLEAN
- BIT
- BIT VARYING
- DATE

For information regarding their semantics, please see SQL:1999 and link:https://github.com/partiql-lang/TODO[RFC-TODO].

== Type Conversions

=== Type Relationships

The relationships between types follows a pattern similar to SQL:1999. That is, they are defined by a set of casts that aid in determining which functions are invoked, what is inserted into the database environment, and more. Below are defined the set of casts applicable to each of PartiQL's predefined data types:

=== Implicit Conversions

TODO

=== Explicit Conversions

TODO

== Type Precedence

TODO

== Related Ongoing Work

The topics of type precedence, function resolution, implicit coercions, and explict conversions are covered in link:https://github.com/partiql-lang/TODO[RFC-TODO].

== Future Work

The topics of user-defined types shall be covered in future RFCs.

== Appendix

.Acronym Table (Quick Reference)
[cols="1,1"]
|===
|Acronym |Definition

|MFP
|Maximum Finite Precision of Numeric Data Type. This is largely used for function signature generation.

|MP
| Maximum Precision of Numeric Data Type.

|===
.SQL:1999 Pre-Defined Data Types
****
[cols="1,1"]
|===
|Type Family |Exact SQL:1999 Type

.3+|Character String Types
|CHARACTER (length)

|CHARACTER VARYING (length)

|CHARACTER LARGE OBJECT (large object length)

|Binary String Types
|BINARY LARGE OBJECT (large object length)

.2+|Bit String Types
|BIT (length)

|BIT VARYING (length)

.2+|Large Object String Types
|CHARACTER LARGE OBJECT (large object length)

|BINARY LARGE OBJECT (large object length)

.4+|Exact Numeric Types
|SMALLINT

|INTEGER

|NUMERIC (precision, scale)

|DECIMAL (precision, scale)

.3+|Approximate Numeric Types
|REAL

|DOUBLE PRECISION

|FLOAT (precision)

.2+|Time Types
|TIME WITH TIME ZONE (time precision)

|TIME WITHOUT TIME ZONE (time precision)

.2+|Timestamp Types
|TIMESTAMP WITH TIME ZONE (timestamp precision)

|TIMESTAMP WITHOUT TIME ZONE (timestamp precision)

|Date Types
|DATE

|Interval Types
|INTERVAL (precision)
|===
****

== END

=== Open Questions

- What should be the naming of `UNBOUNDED INT`, `UNBOUNDED NUMERIC`, `UNBOUNDED TIMESTAMP`? Maybe: `ARBITRARY PRECISION INT`, `ARBITRARY PRECISION NUMERIC`, `ARBITRARY PRECISION TIMESTAMP`?
